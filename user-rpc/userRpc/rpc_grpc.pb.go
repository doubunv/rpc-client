// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.19.4
// source: dsl/rpc.proto

package userRpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	UserLoginService_ParseToken_FullMethodName        = "/rpc.UserLoginService/ParseToken"
	UserLoginService_LoginByAccount_FullMethodName    = "/rpc.UserLoginService/LoginByAccount"
	UserLoginService_LoginByEmail_FullMethodName      = "/rpc.UserLoginService/LoginByEmail"
	UserLoginService_Logout_FullMethodName            = "/rpc.UserLoginService/Logout"
	UserLoginService_RegisterByAccount_FullMethodName = "/rpc.UserLoginService/RegisterByAccount"
	UserLoginService_RegisterByEmail_FullMethodName   = "/rpc.UserLoginService/RegisterByEmail"
)

// UserLoginServiceClient is the client API for UserLoginService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserLoginServiceClient interface {
	ParseToken(ctx context.Context, in *ParseTokenReq, opts ...grpc.CallOption) (*ParseTokenResp, error)
	LoginByAccount(ctx context.Context, in *LoginByAccountReq, opts ...grpc.CallOption) (*LoginByAccountResp, error)
	LoginByEmail(ctx context.Context, in *LoginByEmailReq, opts ...grpc.CallOption) (*LoginByEmailResp, error)
	Logout(ctx context.Context, in *LogoutReq, opts ...grpc.CallOption) (*LogoutResp, error)
	RegisterByAccount(ctx context.Context, in *RegisterByAccountReq, opts ...grpc.CallOption) (*RegisterByAccountResp, error)
	RegisterByEmail(ctx context.Context, in *RegisterByEmailReq, opts ...grpc.CallOption) (*RegisterByEmailResp, error)
}

type userLoginServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserLoginServiceClient(cc grpc.ClientConnInterface) UserLoginServiceClient {
	return &userLoginServiceClient{cc}
}

func (c *userLoginServiceClient) ParseToken(ctx context.Context, in *ParseTokenReq, opts ...grpc.CallOption) (*ParseTokenResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ParseTokenResp)
	err := c.cc.Invoke(ctx, UserLoginService_ParseToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userLoginServiceClient) LoginByAccount(ctx context.Context, in *LoginByAccountReq, opts ...grpc.CallOption) (*LoginByAccountResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginByAccountResp)
	err := c.cc.Invoke(ctx, UserLoginService_LoginByAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userLoginServiceClient) LoginByEmail(ctx context.Context, in *LoginByEmailReq, opts ...grpc.CallOption) (*LoginByEmailResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginByEmailResp)
	err := c.cc.Invoke(ctx, UserLoginService_LoginByEmail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userLoginServiceClient) Logout(ctx context.Context, in *LogoutReq, opts ...grpc.CallOption) (*LogoutResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LogoutResp)
	err := c.cc.Invoke(ctx, UserLoginService_Logout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userLoginServiceClient) RegisterByAccount(ctx context.Context, in *RegisterByAccountReq, opts ...grpc.CallOption) (*RegisterByAccountResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterByAccountResp)
	err := c.cc.Invoke(ctx, UserLoginService_RegisterByAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userLoginServiceClient) RegisterByEmail(ctx context.Context, in *RegisterByEmailReq, opts ...grpc.CallOption) (*RegisterByEmailResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterByEmailResp)
	err := c.cc.Invoke(ctx, UserLoginService_RegisterByEmail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserLoginServiceServer is the server API for UserLoginService service.
// All implementations must embed UnimplementedUserLoginServiceServer
// for forward compatibility.
type UserLoginServiceServer interface {
	ParseToken(context.Context, *ParseTokenReq) (*ParseTokenResp, error)
	LoginByAccount(context.Context, *LoginByAccountReq) (*LoginByAccountResp, error)
	LoginByEmail(context.Context, *LoginByEmailReq) (*LoginByEmailResp, error)
	Logout(context.Context, *LogoutReq) (*LogoutResp, error)
	RegisterByAccount(context.Context, *RegisterByAccountReq) (*RegisterByAccountResp, error)
	RegisterByEmail(context.Context, *RegisterByEmailReq) (*RegisterByEmailResp, error)
	mustEmbedUnimplementedUserLoginServiceServer()
}

// UnimplementedUserLoginServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserLoginServiceServer struct{}

func (UnimplementedUserLoginServiceServer) ParseToken(context.Context, *ParseTokenReq) (*ParseTokenResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ParseToken not implemented")
}
func (UnimplementedUserLoginServiceServer) LoginByAccount(context.Context, *LoginByAccountReq) (*LoginByAccountResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoginByAccount not implemented")
}
func (UnimplementedUserLoginServiceServer) LoginByEmail(context.Context, *LoginByEmailReq) (*LoginByEmailResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoginByEmail not implemented")
}
func (UnimplementedUserLoginServiceServer) Logout(context.Context, *LogoutReq) (*LogoutResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Logout not implemented")
}
func (UnimplementedUserLoginServiceServer) RegisterByAccount(context.Context, *RegisterByAccountReq) (*RegisterByAccountResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterByAccount not implemented")
}
func (UnimplementedUserLoginServiceServer) RegisterByEmail(context.Context, *RegisterByEmailReq) (*RegisterByEmailResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterByEmail not implemented")
}
func (UnimplementedUserLoginServiceServer) mustEmbedUnimplementedUserLoginServiceServer() {}
func (UnimplementedUserLoginServiceServer) testEmbeddedByValue()                          {}

// UnsafeUserLoginServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserLoginServiceServer will
// result in compilation errors.
type UnsafeUserLoginServiceServer interface {
	mustEmbedUnimplementedUserLoginServiceServer()
}

func RegisterUserLoginServiceServer(s grpc.ServiceRegistrar, srv UserLoginServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserLoginServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserLoginService_ServiceDesc, srv)
}

func _UserLoginService_ParseToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ParseTokenReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserLoginServiceServer).ParseToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserLoginService_ParseToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserLoginServiceServer).ParseToken(ctx, req.(*ParseTokenReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserLoginService_LoginByAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginByAccountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserLoginServiceServer).LoginByAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserLoginService_LoginByAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserLoginServiceServer).LoginByAccount(ctx, req.(*LoginByAccountReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserLoginService_LoginByEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginByEmailReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserLoginServiceServer).LoginByEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserLoginService_LoginByEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserLoginServiceServer).LoginByEmail(ctx, req.(*LoginByEmailReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserLoginService_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogoutReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserLoginServiceServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserLoginService_Logout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserLoginServiceServer).Logout(ctx, req.(*LogoutReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserLoginService_RegisterByAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterByAccountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserLoginServiceServer).RegisterByAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserLoginService_RegisterByAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserLoginServiceServer).RegisterByAccount(ctx, req.(*RegisterByAccountReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserLoginService_RegisterByEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterByEmailReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserLoginServiceServer).RegisterByEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserLoginService_RegisterByEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserLoginServiceServer).RegisterByEmail(ctx, req.(*RegisterByEmailReq))
	}
	return interceptor(ctx, in, info, handler)
}

// UserLoginService_ServiceDesc is the grpc.ServiceDesc for UserLoginService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserLoginService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.UserLoginService",
	HandlerType: (*UserLoginServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ParseToken",
			Handler:    _UserLoginService_ParseToken_Handler,
		},
		{
			MethodName: "LoginByAccount",
			Handler:    _UserLoginService_LoginByAccount_Handler,
		},
		{
			MethodName: "LoginByEmail",
			Handler:    _UserLoginService_LoginByEmail_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _UserLoginService_Logout_Handler,
		},
		{
			MethodName: "RegisterByAccount",
			Handler:    _UserLoginService_RegisterByAccount_Handler,
		},
		{
			MethodName: "RegisterByEmail",
			Handler:    _UserLoginService_RegisterByEmail_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dsl/rpc.proto",
}

const (
	AdminUserService_AdminUserLogin_FullMethodName    = "/rpc.AdminUserService/adminUserLogin"
	AdminUserService_CreateAdminUser_FullMethodName   = "/rpc.AdminUserService/createAdminUser"
	AdminUserService_DeleteAdminUser_FullMethodName   = "/rpc.AdminUserService/deleteAdminUser"
	AdminUserService_AdminUserList_FullMethodName     = "/rpc.AdminUserService/adminUserList"
	AdminUserService_GetAdminDetail_FullMethodName    = "/rpc.AdminUserService/getAdminDetail"
	AdminUserService_UpdateAdminDetail_FullMethodName = "/rpc.AdminUserService/updateAdminDetail"
)

// AdminUserServiceClient is the client API for AdminUserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AdminUserServiceClient interface {
	// 管理员板块
	AdminUserLogin(ctx context.Context, in *AdminUserLoginReq, opts ...grpc.CallOption) (*AdminUserLoginResp, error)
	CreateAdminUser(ctx context.Context, in *CreateAdminUserReq, opts ...grpc.CallOption) (*CreateAdminUserResp, error)
	DeleteAdminUser(ctx context.Context, in *DeleteAdminUserReq, opts ...grpc.CallOption) (*DeleteAdminUserResp, error)
	AdminUserList(ctx context.Context, in *AdminUserListReq, opts ...grpc.CallOption) (*AdminUserListResp, error)
	GetAdminDetail(ctx context.Context, in *GetAdminDetailReq, opts ...grpc.CallOption) (*GetAdminDetailResp, error)
	UpdateAdminDetail(ctx context.Context, in *UpdateAdminDetailReq, opts ...grpc.CallOption) (*UpdateAdminDetailResp, error)
}

type adminUserServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAdminUserServiceClient(cc grpc.ClientConnInterface) AdminUserServiceClient {
	return &adminUserServiceClient{cc}
}

func (c *adminUserServiceClient) AdminUserLogin(ctx context.Context, in *AdminUserLoginReq, opts ...grpc.CallOption) (*AdminUserLoginResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AdminUserLoginResp)
	err := c.cc.Invoke(ctx, AdminUserService_AdminUserLogin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminUserServiceClient) CreateAdminUser(ctx context.Context, in *CreateAdminUserReq, opts ...grpc.CallOption) (*CreateAdminUserResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateAdminUserResp)
	err := c.cc.Invoke(ctx, AdminUserService_CreateAdminUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminUserServiceClient) DeleteAdminUser(ctx context.Context, in *DeleteAdminUserReq, opts ...grpc.CallOption) (*DeleteAdminUserResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteAdminUserResp)
	err := c.cc.Invoke(ctx, AdminUserService_DeleteAdminUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminUserServiceClient) AdminUserList(ctx context.Context, in *AdminUserListReq, opts ...grpc.CallOption) (*AdminUserListResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AdminUserListResp)
	err := c.cc.Invoke(ctx, AdminUserService_AdminUserList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminUserServiceClient) GetAdminDetail(ctx context.Context, in *GetAdminDetailReq, opts ...grpc.CallOption) (*GetAdminDetailResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAdminDetailResp)
	err := c.cc.Invoke(ctx, AdminUserService_GetAdminDetail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminUserServiceClient) UpdateAdminDetail(ctx context.Context, in *UpdateAdminDetailReq, opts ...grpc.CallOption) (*UpdateAdminDetailResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateAdminDetailResp)
	err := c.cc.Invoke(ctx, AdminUserService_UpdateAdminDetail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AdminUserServiceServer is the server API for AdminUserService service.
// All implementations must embed UnimplementedAdminUserServiceServer
// for forward compatibility.
type AdminUserServiceServer interface {
	// 管理员板块
	AdminUserLogin(context.Context, *AdminUserLoginReq) (*AdminUserLoginResp, error)
	CreateAdminUser(context.Context, *CreateAdminUserReq) (*CreateAdminUserResp, error)
	DeleteAdminUser(context.Context, *DeleteAdminUserReq) (*DeleteAdminUserResp, error)
	AdminUserList(context.Context, *AdminUserListReq) (*AdminUserListResp, error)
	GetAdminDetail(context.Context, *GetAdminDetailReq) (*GetAdminDetailResp, error)
	UpdateAdminDetail(context.Context, *UpdateAdminDetailReq) (*UpdateAdminDetailResp, error)
	mustEmbedUnimplementedAdminUserServiceServer()
}

// UnimplementedAdminUserServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAdminUserServiceServer struct{}

func (UnimplementedAdminUserServiceServer) AdminUserLogin(context.Context, *AdminUserLoginReq) (*AdminUserLoginResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AdminUserLogin not implemented")
}
func (UnimplementedAdminUserServiceServer) CreateAdminUser(context.Context, *CreateAdminUserReq) (*CreateAdminUserResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAdminUser not implemented")
}
func (UnimplementedAdminUserServiceServer) DeleteAdminUser(context.Context, *DeleteAdminUserReq) (*DeleteAdminUserResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAdminUser not implemented")
}
func (UnimplementedAdminUserServiceServer) AdminUserList(context.Context, *AdminUserListReq) (*AdminUserListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AdminUserList not implemented")
}
func (UnimplementedAdminUserServiceServer) GetAdminDetail(context.Context, *GetAdminDetailReq) (*GetAdminDetailResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAdminDetail not implemented")
}
func (UnimplementedAdminUserServiceServer) UpdateAdminDetail(context.Context, *UpdateAdminDetailReq) (*UpdateAdminDetailResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAdminDetail not implemented")
}
func (UnimplementedAdminUserServiceServer) mustEmbedUnimplementedAdminUserServiceServer() {}
func (UnimplementedAdminUserServiceServer) testEmbeddedByValue()                          {}

// UnsafeAdminUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AdminUserServiceServer will
// result in compilation errors.
type UnsafeAdminUserServiceServer interface {
	mustEmbedUnimplementedAdminUserServiceServer()
}

func RegisterAdminUserServiceServer(s grpc.ServiceRegistrar, srv AdminUserServiceServer) {
	// If the following call pancis, it indicates UnimplementedAdminUserServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AdminUserService_ServiceDesc, srv)
}

func _AdminUserService_AdminUserLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AdminUserLoginReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminUserServiceServer).AdminUserLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminUserService_AdminUserLogin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminUserServiceServer).AdminUserLogin(ctx, req.(*AdminUserLoginReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminUserService_CreateAdminUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAdminUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminUserServiceServer).CreateAdminUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminUserService_CreateAdminUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminUserServiceServer).CreateAdminUser(ctx, req.(*CreateAdminUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminUserService_DeleteAdminUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAdminUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminUserServiceServer).DeleteAdminUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminUserService_DeleteAdminUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminUserServiceServer).DeleteAdminUser(ctx, req.(*DeleteAdminUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminUserService_AdminUserList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AdminUserListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminUserServiceServer).AdminUserList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminUserService_AdminUserList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminUserServiceServer).AdminUserList(ctx, req.(*AdminUserListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminUserService_GetAdminDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAdminDetailReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminUserServiceServer).GetAdminDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminUserService_GetAdminDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminUserServiceServer).GetAdminDetail(ctx, req.(*GetAdminDetailReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminUserService_UpdateAdminDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAdminDetailReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminUserServiceServer).UpdateAdminDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminUserService_UpdateAdminDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminUserServiceServer).UpdateAdminDetail(ctx, req.(*UpdateAdminDetailReq))
	}
	return interceptor(ctx, in, info, handler)
}

// AdminUserService_ServiceDesc is the grpc.ServiceDesc for AdminUserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AdminUserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.AdminUserService",
	HandlerType: (*AdminUserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "adminUserLogin",
			Handler:    _AdminUserService_AdminUserLogin_Handler,
		},
		{
			MethodName: "createAdminUser",
			Handler:    _AdminUserService_CreateAdminUser_Handler,
		},
		{
			MethodName: "deleteAdminUser",
			Handler:    _AdminUserService_DeleteAdminUser_Handler,
		},
		{
			MethodName: "adminUserList",
			Handler:    _AdminUserService_AdminUserList_Handler,
		},
		{
			MethodName: "getAdminDetail",
			Handler:    _AdminUserService_GetAdminDetail_Handler,
		},
		{
			MethodName: "updateAdminDetail",
			Handler:    _AdminUserService_UpdateAdminDetail_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dsl/rpc.proto",
}

const (
	UserService_GetUserDetailById_FullMethodName        = "/rpc.UserService/GetUserDetailById"
	UserService_GetUserListByPage_FullMethodName        = "/rpc.UserService/GetUserListByPage"
	UserService_GetUserListByIds_FullMethodName         = "/rpc.UserService/GetUserListByIds"
	UserService_UpdateUserGoogleCodeById_FullMethodName = "/rpc.UserService/UpdateUserGoogleCodeById"
	UserService_CheckUserGoogleCodeById_FullMethodName  = "/rpc.UserService/CheckUserGoogleCodeById"
	UserService_UpdateUserDetailById_FullMethodName     = "/rpc.UserService/UpdateUserDetailById"
)

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
	GetUserDetailById(ctx context.Context, in *GetUserDetailByIdReq, opts ...grpc.CallOption) (*GetUserDetailByIdResp, error)
	GetUserListByPage(ctx context.Context, in *GetUserListByPageReq, opts ...grpc.CallOption) (*GetUserListByPageResp, error)
	GetUserListByIds(ctx context.Context, in *GetUserListByIdsReq, opts ...grpc.CallOption) (*GetUserListByIdsResp, error)
	UpdateUserGoogleCodeById(ctx context.Context, in *UpdateUserGoogleCodeByIdReq, opts ...grpc.CallOption) (*UpdateUserGoogleCodeByIdResp, error)
	CheckUserGoogleCodeById(ctx context.Context, in *CheckUserGoogleCodeByIdReq, opts ...grpc.CallOption) (*CheckUserGoogleCodeByIdResp, error)
	UpdateUserDetailById(ctx context.Context, in *UpdateUserDetailByIdReq, opts ...grpc.CallOption) (*UpdateUserDetailByIdResp, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) GetUserDetailById(ctx context.Context, in *GetUserDetailByIdReq, opts ...grpc.CallOption) (*GetUserDetailByIdResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserDetailByIdResp)
	err := c.cc.Invoke(ctx, UserService_GetUserDetailById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUserListByPage(ctx context.Context, in *GetUserListByPageReq, opts ...grpc.CallOption) (*GetUserListByPageResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserListByPageResp)
	err := c.cc.Invoke(ctx, UserService_GetUserListByPage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUserListByIds(ctx context.Context, in *GetUserListByIdsReq, opts ...grpc.CallOption) (*GetUserListByIdsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserListByIdsResp)
	err := c.cc.Invoke(ctx, UserService_GetUserListByIds_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UpdateUserGoogleCodeById(ctx context.Context, in *UpdateUserGoogleCodeByIdReq, opts ...grpc.CallOption) (*UpdateUserGoogleCodeByIdResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateUserGoogleCodeByIdResp)
	err := c.cc.Invoke(ctx, UserService_UpdateUserGoogleCodeById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) CheckUserGoogleCodeById(ctx context.Context, in *CheckUserGoogleCodeByIdReq, opts ...grpc.CallOption) (*CheckUserGoogleCodeByIdResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckUserGoogleCodeByIdResp)
	err := c.cc.Invoke(ctx, UserService_CheckUserGoogleCodeById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UpdateUserDetailById(ctx context.Context, in *UpdateUserDetailByIdReq, opts ...grpc.CallOption) (*UpdateUserDetailByIdResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateUserDetailByIdResp)
	err := c.cc.Invoke(ctx, UserService_UpdateUserDetailById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility.
type UserServiceServer interface {
	GetUserDetailById(context.Context, *GetUserDetailByIdReq) (*GetUserDetailByIdResp, error)
	GetUserListByPage(context.Context, *GetUserListByPageReq) (*GetUserListByPageResp, error)
	GetUserListByIds(context.Context, *GetUserListByIdsReq) (*GetUserListByIdsResp, error)
	UpdateUserGoogleCodeById(context.Context, *UpdateUserGoogleCodeByIdReq) (*UpdateUserGoogleCodeByIdResp, error)
	CheckUserGoogleCodeById(context.Context, *CheckUserGoogleCodeByIdReq) (*CheckUserGoogleCodeByIdResp, error)
	UpdateUserDetailById(context.Context, *UpdateUserDetailByIdReq) (*UpdateUserDetailByIdResp, error)
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserServiceServer struct{}

func (UnimplementedUserServiceServer) GetUserDetailById(context.Context, *GetUserDetailByIdReq) (*GetUserDetailByIdResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserDetailById not implemented")
}
func (UnimplementedUserServiceServer) GetUserListByPage(context.Context, *GetUserListByPageReq) (*GetUserListByPageResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserListByPage not implemented")
}
func (UnimplementedUserServiceServer) GetUserListByIds(context.Context, *GetUserListByIdsReq) (*GetUserListByIdsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserListByIds not implemented")
}
func (UnimplementedUserServiceServer) UpdateUserGoogleCodeById(context.Context, *UpdateUserGoogleCodeByIdReq) (*UpdateUserGoogleCodeByIdResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserGoogleCodeById not implemented")
}
func (UnimplementedUserServiceServer) CheckUserGoogleCodeById(context.Context, *CheckUserGoogleCodeByIdReq) (*CheckUserGoogleCodeByIdResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckUserGoogleCodeById not implemented")
}
func (UnimplementedUserServiceServer) UpdateUserDetailById(context.Context, *UpdateUserDetailByIdReq) (*UpdateUserDetailByIdResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserDetailById not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}
func (UnimplementedUserServiceServer) testEmbeddedByValue()                     {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserService_ServiceDesc, srv)
}

func _UserService_GetUserDetailById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserDetailByIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUserDetailById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUserDetailById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUserDetailById(ctx, req.(*GetUserDetailByIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUserListByPage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserListByPageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUserListByPage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUserListByPage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUserListByPage(ctx, req.(*GetUserListByPageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUserListByIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserListByIdsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUserListByIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUserListByIds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUserListByIds(ctx, req.(*GetUserListByIdsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UpdateUserGoogleCodeById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserGoogleCodeByIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UpdateUserGoogleCodeById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UpdateUserGoogleCodeById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UpdateUserGoogleCodeById(ctx, req.(*UpdateUserGoogleCodeByIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_CheckUserGoogleCodeById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckUserGoogleCodeByIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CheckUserGoogleCodeById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_CheckUserGoogleCodeById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CheckUserGoogleCodeById(ctx, req.(*CheckUserGoogleCodeByIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UpdateUserDetailById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserDetailByIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UpdateUserDetailById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UpdateUserDetailById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UpdateUserDetailById(ctx, req.(*UpdateUserDetailByIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUserDetailById",
			Handler:    _UserService_GetUserDetailById_Handler,
		},
		{
			MethodName: "GetUserListByPage",
			Handler:    _UserService_GetUserListByPage_Handler,
		},
		{
			MethodName: "GetUserListByIds",
			Handler:    _UserService_GetUserListByIds_Handler,
		},
		{
			MethodName: "UpdateUserGoogleCodeById",
			Handler:    _UserService_UpdateUserGoogleCodeById_Handler,
		},
		{
			MethodName: "CheckUserGoogleCodeById",
			Handler:    _UserService_CheckUserGoogleCodeById_Handler,
		},
		{
			MethodName: "UpdateUserDetailById",
			Handler:    _UserService_UpdateUserDetailById_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dsl/rpc.proto",
}
